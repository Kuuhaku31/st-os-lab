# 实验六 RCU 锁

# 原理

linux 内核开发了很多种锁，用于控制并发任务对临界资源数据的访问顺序，最常见的如互斥体，信号量，还有用于一些特定场景的锁，比如自旋锁，通常用于临界资源操作比较简短， 且临界资源为中断和内核共同访问的场景。

但我们知道，锁固然对数据有保护作用，但对系统的性能也会产生很大的影响，因此内核工程师也针对各种场景设计出一些特殊用途的锁，用于提高访问的效率，减少线程等待的时间。

有一种场景，对临界资源的访问多数为读者，少数为写者，使用互斥体，信号量或者自旋锁的话，一个读者也需要等其他读者释放了锁之后才能获取锁，进而操作临界资源，这个其实是一种资源的浪费，同时，也存在着优化的空间。

因此，内核为这个场景开发了 RCU 锁，即 Read-Copy-Update。**RCU 锁允许所有的读者并发访问临界资源**，对于读者来讲，相当于是一个无锁的访问，没有任何性能的损失，同时 RCU 也允许写者修改临界资源数据，只不过 RCU 采用了延时回收的策略来完成修改动作，即写者修改的数据要等到所有的读者都退出临界资源后才拷贝到临界资源中，这个拷贝的动作可以是由 RCU 的内核线程来完成，所以写者的性能也是几乎没有损失的。

## 实验设计

本实验设计了一个图书馆的场景，包含了若干个图书馆管理员的线程，若干个学生的线程，和若干本图书

- 图书管理员：读者，定期遍历图书
- 学生：写者，首先借阅图书，然后归还图书
- 图书：需要被保护的临界资源

本实验使用 **RCU** 来保护读者和写者对图书资源的访问，同时也使用了一个**自旋锁**来控制两个写者对同一本图书借阅的场景。
