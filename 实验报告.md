# 操作系统实践报告

## 实验五 麒麟操作系统进程同步

问题：

当程序尝试读取 shareData 时，即运行到 for(int i = 0; i < 10; i++) shareData->data[i] = 0; 时，出现段错误 (core dumped)
段错误 (核心已转储)问题

AI: 问题根源基本可以确定：

你的 shmat() 调用失败了，但你把失败返回值（(void\*)-1）当作有效指针使用，从而在访问 shareData->data[i] 时触发段错误。

改进程序：

1. 分离（detach）当前进程对共享内存的映射

使用：

shmdt(shm);

对应你的代码：

shmdt(shareData);

只断开当前进程的映射，不会删除共享内存段。

2. 删除（remove）共享内存段

使用：

shmctl(shm_id, IPC_RMID, NULL);

这一步才是真正释放共享内存。

删除后：

已 attach 的进程仍然可以访问共享内存

所有进程 detach 后，共享内存被真正回收

不能再 shmat 该 key

### 生产者-消费者

指导书问题：

```c++
// 如果前位置与后位置相等，说明缓冲池已空，返回-1
if(data->front == data->rear)
    return -1;
```

没有释放锁就返回

改为

```c++
// 如果前位置与后位置相等，说明缓冲池已空，返回-1
if(data->front == data->rear)
{
    // 释放同步信号量
    sem_post(&sem->sync);
    return -1;
}
```

- 利用文件实现进程间共享数据

当我在进程运行时删除文件

也能正常读取数据

推测操作系统仅删除指针

数据依然留在外存上原本位置

所以可以正常读取
